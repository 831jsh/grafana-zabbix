{"version":3,"sources":["../../../../../src/datasource-zabbix/zabbix/connectors/sql/sqlConnector.js"],"names":["convertGrafanaTSResponse","time_series","items","addHostName","hosts","_","uniqBy","flatten","map","grafanaSeries","itemid","series","name","item","find","alias","keys","length","host","hostid","datapoints","cloneDeep","points","target","sortBy","compactSQLQuery","query","replace","mysql","postgres","DBConnector","supportedDatabases","DEFAULT_QUERY_LIMIT","HISTORY_TO_TABLE_MAP","TREND_TO_TABLE_MAP","consolidateByFunc","consolidateByTrendColumns","SQLConnector","options","backendSrv","datasourceSrv","limit","sqlDialect","then","loadSQLDialect","datasourceType","testQuery","invokeSQLQuery","timeFrom","timeTill","intervalMs","consolidateBy","intervalSec","Math","ceil","aggFunction","grouped_items","groupBy","promises","value_type","itemids","join","table","historyQuery","Promise","all","results","valueColumn","includes","trendsQuery","history","queryDef","refId","format","datasourceId","rawSql","maxDataPoints","datasourceRequest","url","method","data","queries","response"],"mappings":"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","file":"sqlConnector.js","sourcesContent":["import _ from 'lodash';\nimport mysql from './mysql';\nimport postgres from './postgres';\nimport DBConnector from '../dbConnector';\n\nconst supportedDatabases = {\n  mysql: 'mysql',\n  postgres: 'postgres'\n};\n\nconst DEFAULT_QUERY_LIMIT = 10000;\nconst HISTORY_TO_TABLE_MAP = {\n  '0': 'history',\n  '1': 'history_str',\n  '2': 'history_log',\n  '3': 'history_uint',\n  '4': 'history_text'\n};\n\nconst TREND_TO_TABLE_MAP = {\n  '0': 'trends',\n  '3': 'trends_uint'\n};\n\nconst consolidateByFunc = {\n  'avg': 'AVG',\n  'min': 'MIN',\n  'max': 'MAX',\n  'sum': 'SUM',\n  'count': 'COUNT'\n};\n\nconst consolidateByTrendColumns = {\n  'avg': 'value_avg',\n  'min': 'value_min',\n  'max': 'value_max'\n};\n\nexport class SQLConnector extends DBConnector {\n  constructor(options, backendSrv, datasourceSrv) {\n    super(options, backendSrv, datasourceSrv);\n\n    this.limit = options.limit || DEFAULT_QUERY_LIMIT;\n    this.sqlDialect = null;\n\n    super.loadDBDataSource()\n    .then(() => this.loadSQLDialect());\n  }\n\n  loadSQLDialect() {\n    if (this.datasourceType === supportedDatabases.postgres) {\n      this.sqlDialect = postgres;\n    } else {\n      this.sqlDialect = mysql;\n    }\n  }\n\n  /**\n   * Try to invoke test query for one of Zabbix database tables.\n   */\n  testDataSource() {\n    let testQuery = this.sqlDialect.testQuery();\n    return this.invokeSQLQuery(testQuery);\n  }\n\n  getHistory(items, timeFrom, timeTill, options) {\n    let {intervalMs, consolidateBy} = options;\n    let intervalSec = Math.ceil(intervalMs / 1000);\n\n    consolidateBy = consolidateBy || 'avg';\n    let aggFunction = consolidateByFunc[consolidateBy];\n\n    // Group items by value type and perform request for each value type\n    let grouped_items = _.groupBy(items, 'value_type');\n    let promises = _.map(grouped_items, (items, value_type) => {\n      let itemids = _.map(items, 'itemid').join(', ');\n      let table = HISTORY_TO_TABLE_MAP[value_type];\n      let query = this.sqlDialect.historyQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction);\n\n      query = compactSQLQuery(query);\n      return this.invokeSQLQuery(query);\n    });\n\n    return Promise.all(promises).then(results => {\n      return _.flatten(results);\n    });\n  }\n\n  getTrends(items, timeFrom, timeTill, options) {\n    let { intervalMs, consolidateBy } = options;\n    let intervalSec = Math.ceil(intervalMs / 1000);\n\n    consolidateBy = consolidateBy || 'avg';\n    let aggFunction = consolidateByFunc[consolidateBy];\n\n    // Group items by value type and perform request for each value type\n    let grouped_items = _.groupBy(items, 'value_type');\n    let promises = _.map(grouped_items, (items, value_type) => {\n      let itemids = _.map(items, 'itemid').join(', ');\n      let table = TREND_TO_TABLE_MAP[value_type];\n      let valueColumn = _.includes(['avg', 'min', 'max'], consolidateBy) ? consolidateBy : 'avg';\n      valueColumn = consolidateByTrendColumns[valueColumn];\n      let query = this.sqlDialect.trendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn);\n\n      query = compactSQLQuery(query);\n      return this.invokeSQLQuery(query);\n    });\n\n    return Promise.all(promises).then(results => {\n      return _.flatten(results);\n    });\n  }\n\n  handleGrafanaTSResponse(history, items, addHostName = true) {\n    return convertGrafanaTSResponse(history, items, addHostName);\n  }\n\n  invokeSQLQuery(query) {\n    let queryDef = {\n      refId: 'A',\n      format: 'time_series',\n      datasourceId: this.datasourceId,\n      rawSql: query,\n      maxDataPoints: this.limit\n    };\n\n    return this.backendSrv.datasourceRequest({\n      url: '/api/tsdb/query',\n      method: 'POST',\n      data: {\n        queries: [queryDef],\n      }\n    })\n    .then(response => {\n      let results = response.data.results;\n      if (results['A']) {\n        return results['A'].series;\n      } else {\n        return null;\n      }\n    });\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nfunction convertGrafanaTSResponse(time_series, items, addHostName) {\n  //uniqBy is needed to deduplicate\n  var hosts = _.uniqBy(_.flatten(_.map(items, 'hosts')), 'hostid');\n  let grafanaSeries = _.map(time_series, series => {\n    let itemid = series.name;\n    var item = _.find(items, {'itemid': itemid});\n    var alias = item.name;\n    //only when actual multi hosts selected\n    if (_.keys(hosts).length > 1 && addHostName) {\n      var host = _.find(hosts, {'hostid': item.hostid});\n      alias = host.name + \": \" + alias;\n    }\n    // CachingProxy deduplicates requests and returns one time series for equal queries.\n    // Clone is needed to prevent changing of series object shared between all targets.\n    let datapoints = _.cloneDeep(series.points);\n    return {\n      target: alias,\n      datapoints: datapoints\n    };\n  });\n\n  return _.sortBy(grafanaSeries, 'target');\n}\n\nfunction compactSQLQuery(query) {\n  return query.replace(/\\s+/g, ' ');\n}\n"]}